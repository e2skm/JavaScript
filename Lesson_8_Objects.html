<!--Lesson 8 Objects-->
<!-- Objects group related values and allow us to group and use mulitple values-->
<!DOCTYPE html>
<html>
  <head>
    <title>
      Objects
    </title>

  </head>
  <body>
    
    <script>
      /* Creating an object: syntax is similar to JSON but contains more features. Although JSON syntax contains less features it is more universal and can be understood by almost every programming language (useful for sending data between computers and for data storage)*/
      const product = {
        name: 'socks',
        price: 1090
      };

      /* Viewing an object */
      console.log(product);
      /* Viewing/ Accessing a specific property (Dot Notation)*/
      console.log(product.name);
      console.log('R',product.price);

      /* Update a property's value */
      product.name = 'cotton socks';
      console.log(product);
      
      /* Creating a new property */
      product.newProperty = true;
      console.log(product);

      /* Deleting an object property */ 
      delete product.newProperty;
      console.log(product);

      console.log(typeof product);

      const product2 = {
        name: 'shirt',
        'delivery-time': '1 day',
        /* Nested Objects: You can create an object inside an object We use nested object to organise our values*/
        rating: {
          stars:4.5,
          count: 87
        },
        /* We can also place functions inside objects  Note: Functions are also values.*/
        /* Functions inside an object are refered to as Methods*/ 
        fun: function function1 (){
          console.log('Function inside object ');
        },
        fun2: function function1 (){
          console.log('Anoter function inside object ');
        }
        
      };
      /* Another way of accessing/ viewing values (Bracket Notation)*/ 
      console.log(product2['name']);
      /* Use dot notation by default it is easier to write and read but for properties that don't work with dot notation use bracket notation */
      console.log(product2['delivery-time']);

      /* Accessing a values inside a nested object */
      console.log('Rating-stars',product2['rating']['stars']);
      console.log('Rating-count',product2.rating.count);

      /* Accessing a function inside an object*/
      product2['fun']();
      product2.fun2();

      /* console.log() is an example of a method, console is an object and log is a function saved inside the console object Math.random is another example of a Method*/
      console.log(typeof console);
      console.log(typeof console.log)
      console.log(typeof Math);
      console.log(typeof Math.random)
      /* Built-in-Objects the above are examples of built-in-objects because they are provided by the language there are many built-in-objects provided by javascript we will discuss JSON and localStorage*/
      /*The bulit-in JSON object: because of the similarity in the syntaxes of Javascript objects and JSON objects Javascript objects can be turned into JSON objects and vice versa. JSON has methods that make this possible */ 
      const jsonString = JSON.stringify(product2);
      console.log(jsonString);
      /* This is actually a string in JSON syntax */
      console.log(typeof jsonString);
      javaScriptObject = JSON.parse(jsonString);
      console.log(javaScriptObject);
      console.log(typeof javaScriptObject);
      /* The built-in localStorage object: is used to save values more permanently. Note: variables are temporary, they only exist on the current page, all variable values are lost when the page is refreshed/closed. However localStorage does not get deleted when we refresh the page. localStore  only supports strings*/
      /* Saving something to localStorage*/ 
      localStorage.setItem('message','I love Money');
      /* Accessing something from localStorage*/
      console.log(localStorage.getItem('message'));
      /* Removing something from localStorage*/
      localStorage.removeItem('message');
      console.log(localStorage.getItem('message'));

      /* Null vs Undefined: While both are falsy values. They have different use-cases. We use null when we intentionally want something to be empty */ 
      
      /*Auto-boxing: Javascript automatically wraps variables (of all types numbers, strings and booleans) in special objects these objects have properties and methods. Because of auto-boxing variables also have properties and methods. Note: auto-boxing does not work with null and undefined*/
      const message = 'I need Money';
      console.log('The string has: ',message.length,'letters');
      console.log(message.toUpperCase());

      /* Objects are References: When an object is create the actual value is created somewhere in the computers memory. This object acts as a reference that points to the location of the value in the computers memory. It is like a shortcut on your desktop in that it is not the actual file but is points to where the actual file is located.*/
      const object1 = {
        message: 'Hello'
      };
      /* The reason it works this way is to make the language more effecient. The code below does not create a copy of the object rather it creates a copy of the reference that points to the object (Copy by reference). This makes the language effecient even if the objects it huge. */
      const object2 = object1;

      /* Even though the object is a constant we where able to change the message(value) because the object is just a pointer to the value. const in this case only prevents us from changing the reference in the variable it does not prevent us from reaching into the reference and changing the value stored*/
      object1.message = 'Good Job!';  
      console.log(object1);
      console.log(object2);

      /* Even if two objects contains the same  values they may never equal because objects are only references */
      const object3 = {
        message: 'Good Job!'
      };
      /* Object 1 and Object 3 point to different locations in the computer's memory  */
      console.log(object1 === object3);
      /* Whenever you want to compare the values stored inside 2 or more objects do it manually using either dot or brackets notation */
      console.log(object1.message === object3['message']);
      /* Object 1 and Object 2 are equal because object 2 is a copy of reference, in other words the point to the same location in the computers memory */
      console.log(object1 === object2);

      /* Shorcuts for objects */
      object4 = {
        text: 'Good Job!',
        price: 799
      };
      // const text = object4.text; const price = object4.price;
      /* Destructing: we can use destructing to deconstruct the above syntax into a shorter syntax. Destructing makes it easier to retrieve properties from an object*/
      const { text, price} = object4;
      console.log(text);
      console.log(price);

      /* Shorthand property:  */ 
      const object5 = {
        //message: message
        /* The above code can be written like this*/
        message
        
      };   
      console.log(object5);
      
            
      /* Shorthand Method */
      const object6 = {
        method: function function2(){
          console.log('Method');
        },  
        /* The below code functions like the code above*/
        method2() {
          console.log('Method2');
        }     
      };
      object6.method();
      object6.method2();






    </script>
  </body>
</html>